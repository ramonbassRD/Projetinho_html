<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Controle de Testes STB Claro</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&family=Roboto+Mono&display=swap" rel="stylesheet">
<style>
    :root {
        --claro-primary: #E2001A;
        --claro-secondary: #000000;
        --claro-accent: #FFFFFF;
        --claro-light-gray: #F5F5F5;
        --claro-dark-gray: #333333;
        --claro-blue: #005AAB;
        --claro-green: #00A859;
        --claro-orange: #FF6D00;
        --dark-gray: var(--claro-dark-gray);
        --red-accent: var(--claro-primary);
        --white: var(--claro-accent);
        --light-gray-bg: #f2eeed;
        --panel-bg: var(--claro-accent);
        --text-color: var(--claro-dark-gray);
        --border-color: #e0e0e0;
        --success-color: var(--claro-green);
        --error-color: var(--claro-primary);
        --warning-color: var(--claro-orange);
        --info-color: var(--claro-blue);
        --selected-gray: #f0f0f0;
        --sidebar-dark-gray: #363636;
        --sidebar-item-hover: #1a1a1a;
        --sidebar-active-border: var(--claro-primary);
        --tab-inactive-bg: #f5f5f5;
        --tab-active-bg: var(--claro-accent);
        --port-active: #E2001A;
        --port-inactive: #CCCCCC;
        --port-executing: #005AAB;
        --port-success: #00A859;
        --port-error: #E2001A;
    }

    * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
    }

    html {
        scroll-behavior: auto !important;
        overflow-x: hidden;
    }

    body {
        font-family: 'Roboto', sans-serif;
        background-color: var(--light-gray-bg);
        color: var(--text-color);
        margin: 0;
        padding: 0;
        display: flex;
        min-height: 100vh;
        overflow-x: hidden;
        font-size: 0.9rem;
        line-height: 1.5;
        overflow-anchor: none;
    }

    .sidebar {
        width: 250px;
        background-color: var(--sidebar-dark-gray);
        color: var(--white);
        position: sticky;
        top: 0;
        height: 100vh;
        overflow-y: auto;
        padding: 15px;
        box-shadow: 0 0 15px rgba(0,0,0,0.5);
        flex-shrink: 0;
        transition: width 0.3s ease;
    }

    .main-content {
        flex-grow: 1;
        padding: 15px;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
        gap: 15px;
        min-height: 100vh;
        overflow-x: hidden;
    }

    .main-content-columns {
        display: flex;
        gap: 15px;
        flex-wrap: wrap;
    }

    .main-content-left, .main-content-middle, .main-content-right {
        flex: 1 1 calc(33.333% - 15px);
        min-width: 280px;
    }

    .panel {
        background-color: var(--panel-bg);
        border-radius: 6px;
        padding: 15px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        margin-bottom: 15px;
    }

    h1, h2, h3, h4 {
        color: var(--claro-dark-gray);
        margin-bottom: 12px;
        font-weight: 500;
    }

    h1 {
        font-size: 1.6rem;
        color: var(--claro-primary);
    }

    h2 {
        font-size: 1.3rem;
        border-bottom: 1px solid var(--border-color);
        padding-bottom: 8px;
    }

    h3 {
        font-size: 1.1rem;
    }

    h4 {
        font-size: 1rem;
    }

    .sidebar h2 {
        color: var(--white);
        border-bottom: 2px solid var(--red-accent);
        padding-bottom: 8px;
        margin-bottom: 15px;
        text-align: center;
        font-size: 1.2rem;
    }

    .sidebar-script-item {
        padding: 10px;
        margin-bottom: 6px;
        background-color: rgba(255,255,255,0.1);
        border-radius: 5px;
        cursor: pointer;
        color: var(--white);
        transition: all 0.2s ease;
        position: relative;
        overflow: hidden;
    }

    .sidebar-script-item:hover {
        background-color: rgba(255,255,255,0.2);
        transform: translateY(-1px);
    }

    .sidebar-script-item.active {
        background-color: var(--red-accent);
        color: var(--white);
        border-left: 3px solid var(--white);
    }

    .script-name {
        font-weight: 500;
        margin-bottom: 4px;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .script-actions {
        display: flex;
        gap: 6px;
        margin-top: 6px;
        flex-wrap: wrap;
    }

    .tabs-container {
        min-height: 100vh;
        overflow: hidden;
    }

    .tabs-header {
        display: flex;
        border-bottom: 1px solid var(--border-color);
        background-color: var(--red-accent);
        border-radius: 6px 6px 0 0;
        overflow: hidden;
    }

    .tab {
        padding: 10px 15px;
        cursor: pointer;
        color: var(--white);
        font-weight: 500;
        text-align: center;
        flex: 1;
        transition: all 0.2s ease;
        font-size: 0.9rem;
    }

    .tab:hover {
        background-color: rgba(255,255,255,0.1);
    }

    .tab.active {
        background-color: #c00016;
        border-bottom: 2px solid var(--white);
    }

    .tab-content {
        display: none;
        padding: 15px 0;
    }

    .tab-content.active {
        display: block;
    }

    .form-group {
        margin-bottom: 12px;
    }

    label {
        display: block;
        margin-bottom: 4px;
        font-weight: 500;
        color: var(--claro-dark-gray);
    }

    input[type="text"],
    input[type="number"],
    select,
    textarea {
        width: 100%;
        padding: 8px;
        border: 1px solid var(--border-color);
        border-radius: 5px;
        font-size: 0.85rem;
        background-color: var(--claro-accent);
        color: var(--claro-dark-gray);
        transition: border-color 0.2s ease;
    }

    input[type="text"]:focus,
    input[type="number"]:focus,
    select:focus,
    textarea:focus {
        outline: none;
        border-color: var(--claro-primary);
        box-shadow: 0 0 0 2px rgba(226, 0, 26, 0.2);
    }

    select {
        appearance: none;
        background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
        background-repeat: no-repeat;
        background-position: right 8px center;
        background-size: 14px;
    }

    .loop-count, .delay-input {
        width: 60px;
        display: inline-block;
        margin-right: 8px;
    }

    button {
        padding: 8px 12px;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-size: 0.85rem;
        font-weight: 500;
        transition: all 0.2s ease;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 6px;
    }

    button:hover {
        transform: translateY(-1px);
        box-shadow: 0 2px 6px rgba(0,0,0,0.1);
    }

    button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
        transform: none !important;
        box-shadow: none !important;
    }

    .btn-execute {
        background-color: var(--claro-secondary);
        color: var(--white);
    }

    .btn-execute:hover {
        background-color: #333333;
    }

    .btn-edit {
        background-color: var(--claro-blue);
        color: var(--white);
    }

    .btn-edit:hover {
        background-color: #004a8f;
    }

    .btn-loop {
        background-color: var(--claro-accent);
        color: var(--claro-dark-gray);
        border: 1px solid var(--border-color);
    }

    .btn-loop:hover {
        background-color: #e0e0e0;
    }

    .btn-combine {
        background-color: var(--claro-primary);
        color: var(--white);
    }

    .btn-combine:hover {
        background-color: #c00016;
    }

    .btn-danger {
        background-color: var(--claro-secondary);
        color: var(--white);
    }

    .btn-danger:hover {
        background-color: #333333;
    }

    .btn-stop {
        background-color: #f44336;
        color: white;
    }

    .btn-stop:hover {
        background-color: #d32f2f;
    }

    .save-log-btn {
        background-color: var(--claro-green);
        color: white;
    }

    .save-log-btn:hover {
        background-color: #008a5e;
    }

    .command-list {
        border: 1px solid var(--border-color);
        border-radius: 5px;
        padding: 8px;
        background-color: var(--light-gray-bg);
        min-height: 120px;
        max-height: 250px;
        overflow-y: auto;
        margin-bottom: 12px;
    }

    .command-item {
        display: flex;
        align-items: center;
        justify-content: space-between;
        background-color: var(--claro-accent);
        border: 1px solid var(--border-color);
        border-radius: 5px;
        padding: 8px;
        margin-bottom: 6px;
        transition: all 0.2s ease;
    }

    .command-item:hover {
        box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }

    .command-item.dragging {
        opacity: 0.5;
        background-color: var(--claro-secondary);
        color: white;
    }

    .command-details {
        flex-grow: 1;
    }

    .command-name {
        font-weight: 500;
        color: var(--claro-dark-gray);
    }

    .command-props {
        color: #666;
        font-size: 0.75rem;
    }

    .status {
        padding: 12px;
        border-radius: 5px;
        margin-bottom: 12px;
        font-weight: 500;
        text-align: center;
    }

    .success {
        background-color: #E8F5E9;
        color: var(--success-color);
        border: 1px solid #C8E6C9;
    }

    .error {
        background-color: #FFEBEE;
        color: var(--error-color);
        border: 1px solid #FFCDD2;
    }

    .warning {
        background-color: #FFFDE7;
        color: var(--warning-color);
        border: 1px solid #FFF9C4;
    }

    .info {
        background-color: #E3F2FD;
        color: var(--info-color);
        border: 1px solid #BBDEFB;
    }

    .execution-logs {
        border: 1px solid var(--border-color);
        border-radius: 5px;
        padding: 12px;
        background-color: var(--light-gray-bg);
        max-height: 250px;
        overflow-y: auto;
        font-family: 'Roboto Mono', monospace;
        font-size: 0.8rem;
    }

    .execution-log-item {
        margin-bottom: 8px;
        padding-bottom: 8px;
        border-bottom: 1px solid #eee;
    }

    .execution-log-item:last-child {
        border-bottom: none;
        margin-bottom: 0;
        padding-bottom: 0;
    }

    .execution-log-timestamp {
        color: var(--claro-primary);
        font-weight: bold;
        margin-right: 6px;
    }

    .execution-log-command {
        color: var(--claro-dark-gray);
    }

    .execution-log-success {
        color: var(--claro-green);
    }

    .execution-log-error {
        color: var(--claro-primary);
    }

    .progress-container {
        margin: 12px 0;
    }

    .progress-bar {
        height: 6px;
        background-color: #eee;
        border-radius: 3px;
        overflow: hidden;
        margin-bottom: 4px;
    }

    .progress-fill {
        height: 100%;
        background-color: var(--claro-primary);
        width: 0%;
        transition: width 0.2s ease;
    }

    .progress-text {
        font-size: 0.75rem;
        color: #666;
        text-align: right;
    }

    .json-viewer-panel {
        margin-top: 12px;
        border: 1px solid var(--border-color);
        border-radius: 5px;
        padding: 12px;
        background-color: var(--panel-bg);
    }

    .json-viewer-title {
        font-weight: 500;
        margin-bottom: 8px;
        color: var(--claro-dark-gray);
    }

    .json-viewer-textarea {
        width: 100%;
        min-height: 120px;
        border: 1px solid var(--border-color);
        border-radius: 5px;
        padding: 8px;
        font-family: 'Roboto Mono', monospace;
        font-size: 0.8rem;
        margin-bottom: 12px;
        resize: vertical;
        background-color: var(--light-gray-bg);
    }

    .json-results-display {
        margin-top: 8px;
        border: 1px solid var(--border-color);
        border-radius: 5px;
        padding: 12px;
        background-color: var(--light-gray-bg);
        min-height: 120px;
        max-height: 250px;
        overflow-y: auto;
        color: var(--claro-dark-gray);
        font-size: 0.8rem;
    }

    .json-result-item {
        margin-bottom: 6px;
        padding-bottom: 6px;
        border-bottom: 1px solid var(--border-color);
        display: flex;
        flex-wrap: wrap;
    }

    .json-result-item:last-child {
        border-bottom: none;
        margin-bottom: 0;
        padding-bottom: 0;
    }

    .json-result-key {
        font-weight: 500;
        color: var(--claro-primary);
        margin-right: 6px;
        flex-shrink: 0;
    }

    .json-result-value {
        color: var(--claro-dark-gray);
        word-break: break-word;
        flex-grow: 1;
    }

    .json-viewer-actions {
        display: flex;
        gap: 8px;
        margin-top: 8px;
        flex-wrap: wrap;
    }

    .script-checkboxes {
        margin-top: 8px;
        max-height: 200px;
        overflow-y: auto;
        padding: 8px;
        border: 1px solid var(--border-color);
        border-radius: 5px;
        background-color: var(--light-gray-bg);
    }

    .script-checkbox-item {
        margin-bottom: 6px;
        display: flex;
        align-items: center;
    }

    .script-checkbox-item input[type="checkbox"] {
        margin-right: 8px;
        transform: scale(1.1);
        accent-color: var(--claro-primary);
    }

    .script-checkbox-item label {
        color: var(--text-color);
        cursor: pointer;
        flex-grow: 1;
    }

    .combination-controls {
        margin-top: 12px;
        display: flex;
        flex-direction: column;
        gap: 8px;
    }

    .flowchart-display {
        margin-top: 12px;
        border: 1px dashed var(--claro-primary);
        padding: 12px;
        border-radius: 5px;
        min-height: 80px;
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: 8px;
        justify-content: center;
        background-color: #fffafa;
    }

    .flowchart-node {
        background-color: var(--claro-dark-gray);
        color: var(--white);
        padding: 6px 12px;
        border-radius: 16px;
        font-size: 0.8rem;
        font-weight: 500;
        display: flex;
        align-items: center;
        gap: 4px;
        box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        position: relative;
    }

    .flowchart-node::after {
        content: '→';
        position: absolute;
        right: -12px;
        color: var(--claro-primary);
        font-weight: bold;
    }

    .flowchart-display .flowchart-node:last-of-type::after {
        content: '';
    }

    /* PORT CONTAINER - MODIFICADO PARA SER MAIS COMPACTO */
    .port-container {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
        gap: 12px;
        margin-top: 12px;
    }

    .port-card {
        background-color: white;
        border-radius: 6px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        padding: 12px;
        transition: all 0.2s ease;
        border-left: 3px solid var(--port-inactive);
    }

    .port-card.active {
        border-left-color: var(--port-active);
        box-shadow: 0 2px 8px rgba(226, 0, 26, 0.2);
    }

    .port-card.executing {
        border-left-color: var(--port-executing);
    }

    .port-card.success {
        border-left-color: var(--port-success);
    }

    .port-card.error {
        border-left-color: var(--port-error);
    }

    .port-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 12px;
        padding-bottom: 8px;
        border-bottom: 1px solid #eee;
    }

    .port-title {
        font-weight: 500;
        font-size: 1rem;
        color: var(--claro-dark-gray);
        display: flex;
        align-items: center;
    }

    .port-number {
        display: inline-flex;
        width: 24px;
        height: 24px;
        background-color: var(--claro-primary);
        color: white;
        border-radius: 50%;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        margin-right: 8px;
        flex-shrink: 0;
        font-size: 0.8rem;
    }

    .port-status {
        font-size: 0.7rem;
        padding: 3px 8px;
        border-radius: 10px;
        background-color: #f0f0f0;
        color: #666;
        font-weight: 500;
    }

    .port-status.active {
        background-color: #E8F5E9;
        color: var(--claro-green);
    }

    .port-status.inactive {
        background-color: #FFEBEE;
        color: var(--claro-primary);
    }

    .port-status.executing {
        background-color: #E3F2FD;
        color: var(--claro-blue);
    }

    .port-controls {
        margin-top: 12px;
    }

    .port-select {
        width: 100%;
        padding: 8px;
        border: 1px solid #ddd;
        border-radius: 5px;
        margin-bottom: 8px;
        font-size: 0.8rem;
    }

    .port-button {
        width: 100%;
        padding: 8px;
        margin-bottom: 6px;
        font-weight: 500;
        font-size: 0.8rem;
    }

    .port-button.secondary {
        background-color: var(--claro-secondary);
        color: white;
    }

    .port-log {
        margin-top: 12px;
        max-height: 150px;
        overflow-y: auto;
        font-size: 0.75rem;
        background-color: #f9f9f9;
        padding: 8px;
        border-radius: 5px;
        border: 1px solid #eee;
    }

    .log-entry {
        margin-bottom: 6px;
        padding-bottom: 6px;
        border-bottom: 1px solid #eee;
        font-size: 0.7rem;
    }

    .log-entry:last-child {
        border-bottom: none;
        margin-bottom: 0;
        padding-bottom: 0;
    }

    .log-time {
        color: #666;
        margin-right: 4px;
    }

    .global-controls {
        background-color: var(--claro-secondary);
        color: white;
        padding: 12px 15px;
        border-radius: 6px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
    }

    .global-title {
        font-weight: 500;
        font-size: 1.1rem;
    }

    .global-buttons {
        display: flex;
        gap: 8px;
    }

    .loading-spinner {
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        border-top: 2px solid white;
        width: 14px;
        height: 14px;
        animation: spin 1s linear infinite;
        display: inline-block;
        vertical-align: middle;
    }

    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

    .log-management {
        margin-top: 15px;
    }

    .log-list {
        max-height: 350px;
        overflow-y: auto;
        border: 1px solid var(--border-color);
        border-radius: 6px;
        padding: 8px;
        background-color: var(--light-gray-bg);
        margin-top: 12px;
    }

    .log-item {
        margin-bottom: 12px;
        padding: 12px;
        background-color: var(--claro-accent);
        border-radius: 5px;
        border-left: 3px solid var(--claro-primary);
        box-shadow: 0 1px 3px rgba(0,0,0,0.05);
    }

    .log-item-header {
        display: flex;
        justify-content: space-between;
        margin-bottom: 8px;
        align-items: center;
    }

    .log-item-name {
        font-weight: 500;
        color: var(--claro-primary);
    }

    .log-item-date {
        color: #666;
        font-size: 0.75rem;
    }

    .log-item-content {
        font-family: 'Roboto Mono', monospace;
        font-size: 0.75rem;
        white-space: pre-wrap;
        margin-bottom: 8px;
    }

    .log-actions {
        display: flex;
        gap: 8px;
        margin-top: 8px;
    }

    .log-chart-container {
        margin-top: 15px;
        border: 1px solid var(--border-color);
        border-radius: 6px;
        padding: 12px;
        background-color: var(--claro-accent);
    }

    .log-chart-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 12px;
    }

    .log-chart-title {
        font-weight: 500;
        color: var(--claro-primary);
    }

    .log-chart {
        width: 100%;
        height: 250px;
        background-color: var(--light-gray-bg);
        display: flex;
        justify-content: center;
        align-items: center;
        border-radius: 5px;
    }

    .drop-zone {
        border: 2px dashed var(--claro-secondary);
        border-radius: 6px;
        padding: 15px;
        text-align: center;
        margin-top: 12px;
        background-color: rgba(0, 0, 0, 0.05);
        transition: all 0.2s;
    }

    .drop-zone.active {
        background-color: rgba(0, 153, 204, 0.1);
        border-color: var(--success-color);
    }

    .drop-zone p {
        margin: 0;
        color: var(--claro-secondary);
    }

    /* Estilos para a aba de agendamento */
    .schedule-item {
        background-color: white;
        border-radius: 6px;
        padding: 12px;
        margin-bottom: 12px;
        box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        border-left: 3px solid var(--claro-primary);
    }
    
    .schedule-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 8px;
    }
    
    .schedule-time {
        font-weight: bold;
        font-size: 1rem;
        color: var(--claro-primary);
    }
    
    .schedule-status {
        padding: 3px 8px;
        border-radius: 10px;
        font-size: 0.75rem;
        font-weight: 500;
    }
    
    .schedule-status.active {
        background-color: #E8F5E9;
        color: var(--claro-green);
    }
    
    .schedule-status.inactive {
        background-color: #FFEBEE;
        color: var(--claro-primary);
    }
    
    .schedule-details {
        margin-bottom: 8px;
        font-size: 0.8rem;
    }
    
    .schedule-details div {
        margin-bottom: 4px;
    }
    
    .schedule-actions {
        display: flex;
        gap: 6px;
    }
    
    .schedule-actions button {
        padding: 5px 10px;
        font-size: 0.8rem;
    }
    
    .days-checkboxes {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-top: 4px;
    }
    
    .days-checkboxes label {
        display: flex;
        align-items: center;
        gap: 4px;
        cursor: pointer;
        font-size: 0.8rem;
    }

    /* Loader global */
    #global-loader {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0,0,0,0.5);
        display: none;
        justify-content: center;
        align-items: center;
        z-index: 9999;
    }

    #global-loader .loading-spinner {
        width: 40px;
        height: 40px;
        border-width: 4px;
    }

    /* Notificações */
    .notification {
        position: fixed;
        bottom: 15px;
        right: 15px;
        padding: 12px;
        background-color: var(--claro-green);
        color: white;
        border-radius: 5px;
        z-index: 1000;
        animation: slideIn 0.3s forwards;
        box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        font-size: 0.9rem;
    }

    .notification-error {
        background-color: var(--claro-primary);
    }

    .notification-warning {
        background-color: var(--claro-orange);
    }

    @keyframes slideIn {
        from { transform: translateX(100%); }
        to { transform: translateX(0); }
    }

    .fade-out {
        animation: fadeOut 0.3s forwards;
    }

    @keyframes fadeOut {
        from { opacity: 1; }
        to { opacity: 0; }
    }

    @media (max-width: 1200px) {
        .main-content-columns {
            flex-direction: column;
        }
        .main-content-left, .main-content-middle, .main-content-right {
            flex: 1 1 100%;
        }
        .sidebar {
            width: 100%;
            height: auto;
            position: relative;
        }
        body {
            flex-direction: column;
        }
    }

    @media (max-width: 992px) {
        .port-container {
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
        }
    }

    @media (max-width: 768px) {
        .sidebar, .main-content {
            padding: 12px;
        }
        .panel {
            padding: 12px;
        }
        .tabs-header {
            flex-wrap: wrap;
        }
        .tab {
            flex: 1 1 50%;
            padding: 8px;
            font-size: 0.8rem;
        }
        .port-container {
            grid-template-columns: 1fr;
        }
        .global-controls {
            flex-direction: column;
            gap: 8px;
        }
        .global-buttons {
            flex-wrap: wrap;
            justify-content: center;
        }
        .json-viewer-actions, .script-actions, .execution-controls {
            flex-direction: column;
        }
        button {
            width: 100%;
            margin-bottom: 6px;
        }
        .flowchart-display {
            flex-direction: column;
            align-items: flex-start;
        }
        .flowchart-node::after {
            content: '↓';
            right: auto;
            left: 50%;
            transform: translateX(-50%);
            top: auto;
            bottom: -12px;
        }
        .schedule-actions {
            flex-direction: column;
        }
    }

    @media (max-width: 576px) {
        .sidebar {
            padding: 10px;
        }
        .main-content {
            padding: 10px;
        }
        h1 {
            font-size: 1.4rem;
        }
        h2 {
            font-size: 1.1rem;
        }
        .tab {
            flex: 1 1 100%;
            font-size: 0.75rem;
        }
        .command-item {
            flex-direction: column;
            align-items: flex-start;
            gap: 6px;
        }
        .port-card {
            padding: 10px;
        }
        .port-title {
            font-size: 0.9rem;
        }
        .port-number {
            width: 20px;
            height: 20px;
            font-size: 0.7rem;
        }
    }
</style>




</head>
<body>
    <!-- Loader global -->
    <div id="global-loader">
        <div class="loading-spinner"></div>
    </div>

    <!-- Sidebar -->
    <div class="sidebar">
        <h2>Scripts Salvos</h2>
        <div id="sidebar-scripts-container">
            <p style="text-align: center; color: rgba(255,255,255,0.7);">Nenhum script salvo ainda</p>
        </div>
    </div>
    
    <div class="main-content">
        <!-- Cabeçalho com controles globais -->
        <div class="global-controls">
            <div class="global-title">Controle de Testes STB Claro</div>
            <div class="global-buttons">
                <button id="initializeBtn">Inicializar irNetBox</button>
                <button id="enable-all-ports">Ativar Todas</button>
                <button id="disable-all-ports">Desativar Todas</button>
                <button id="execute-all-scripts">Executar Todos</button>
                <button id="stop-all-executions">Parar Tudo</button>
            </div>
        </div>

        <div class="tabs-container">
            <div class="tabs-header">
                <div class="tab active" data-tab="editor">Editor</div>
                <div class="tab" data-tab="combination">Combinação</div>
                <div class="tab" data-tab="ports">Controle de Portas</div>
                <div class="tab" data-tab="scheduling">Agendamento</div>
                <div class="tab" data-tab="management">Gerenciamento</div>
                <div class="tab" data-tab="import-export">Importar/Exportar</div>
            </div>
            
            <!-- Aba do Editor -->
            <div class="tab-content active" id="editor-tab">
                <div class="main-content-columns">
                    <div class="panel main-content-left">
                        <h1>Criação de Scripts_11 Testes STB Claro</h1>
                        <p>Crie sequências de comandos para executar no seu STB Claro</p>
                        
                        <div class="form-group">
                            <label for="script-name">Nome do Script:</label>
                            <input type="text" id="script-name" placeholder="Ex: Navegar para VOD">
                        </div>
                        
                        <div class="form-group">
                            <label for="command-select">Selecione um Comando:</label>
                            <select id="command-select">
                                <option value="">-- Selecione --</option>
                            </select>
                        </div>
                        
                        <div class="form-group">
                            <label for="command-repeat">Repetir:</label>
                            <input type="number" id="command-repeat" min="1" value="1" class="loop-count"> vezes
                            <label style="display: inline-block; margin-left: 18px;">Atraso:</label>
                            <input type="number" id="command-delay" min="0" value="1200" class="delay-input"> ms
                        </div>
                        
                        <button id="add-command" class="btn-edit">Adicionar Comando</button>
                        
                        <div class="command-list" id="command-list">
                            <p style="text-align: center; color: #999;">Nenhum comando adicionado ainda</p>
                        </div>
                        
                        <div class="form-actions">
                            <button id="save-script" class="btn-combine">Salvar Script</button>
                            <button id="clear-script" class="btn-danger">Limpar Script</button>
                        </div>
                    </div>
                    
                    <div class="panel main-content-right">
                        <h2>Execução de Script</h2>
                        
                        <div id="current-script-info">
                            <h3 id="selected-script-name">Nenhum script selecionado</h3>
                            
                            <div class="form-group">
                                <label for="script-execution-port">Porta:</label>
                                <input type="number" id="script-execution-port" min="1" max="16" value="1">
                            </div>
                            
                            <div class="form-group">
                                <label for="multi-execution-ports">Portas Múltiplas (separadas por vírgula):</label>
                                <input type="text" id="multi-execution-ports" placeholder="Ex: 1,2,3">
                            </div>
                            
                            <div class="execution-controls">
                                <button id="execute-script" class="btn-execute" disabled>Executar</button>
                                <button id="execute-multi-ports" class="btn-execute" disabled>Executar em Múltiplas Portas</button>
                                <button id="loop-script" class="btn-loop" disabled>Executar em Loop</button>
                                <input type="number" id="loop-count" class="loop-count" min="1" value="1" placeholder="Vezes">
                                <button id="stop-script" class="btn-stop" disabled>Parar</button>
                            </div>
                            
                            <div class="progress-container">
                                <div class="progress-bar" id="progress-bar">
                                    <div class="progress-bar-fill" id="progress-bar-fill"></div>
                                </div>
                                <div class="progress-text" id="progress-text">0%</div>
                            </div>
                            
                            <div class="status" id="status"></div>
                            
                            <div class="execution-logs" id="execution-logs">
                                <p>Nenhum log de execução disponível</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Aba de Combinação de Scripts -->
            <div class="tab-content" id="combination-tab">
                <div class="panel">
                    <h2>Combinação de Scripts</h2>
                    <p>Selecione os scripts que deseja combinar em uma nova sequência:</p>
                    
                    <div class="script-checkboxes" id="script-checkboxes">
                        <p>Nenhum script disponível para combinação</p>
                    </div>
                    
                    <div class="combination-controls">
                        <input type="text" id="combined-script-name" placeholder="Nome do novo script combinado">
                        <input type="number" id="combined-script-delay" class="delay-input" min="0" value="1200" placeholder="Atraso (ms) entre scripts">
                        <button id="combine-scripts" class="btn-combine">Combinar Scripts</button>
                    </div>
                    
                    <h3>Pré-visualização:</h3>
                    <div class="flowchart-display" id="flowchart-display">
                        <p style="color: #666;">Selecione scripts para ver a sequência de comandos.</p>
                    </div>
                </div>
            </div>
            
            <!-- Aba de Controle de Portas -->
            <div class="tab-content" id="ports-tab">
                <div class="panel">
                    <h2>Controle de Portas STB</h2>
                    <p>Gerencie e execute scripts em diferentes portas de STB:</p>
                    
                    <div class="port-container" id="port-container">
                        <!-- Portas serão geradas dinamicamente via JavaScript -->
                    </div>
                </div>
            </div>
            
            <!-- Aba de Agendamento -->
            <div class="tab-content" id="scheduling-tab">
                <div class="panel">
                    <h2>Agendamento de Execução</h2>
                    <p>Agende a execução automática de scripts em horários específicos:</p>
                    
                    <div class="form-group">
                        <label for="schedule-script-select">Script:</label>
                        <select id="schedule-script-select" class="port-script-select">
                            <option value="">Selecione um script...</option>
                        </select>
                    </div>
                    
                    <div class="form-group">
                        <label for="schedule-port-select">Porta:</label>
                        <input type="number" id="schedule-port-select" min="1" max="16" value="1">
                    </div>
                    
                    <div class="form-group">
                        <label for="schedule-time">Horário:</label>
                        <input type="time" id="schedule-time" required>
                    </div>
                    
                    <div class="form-group">
                        <label for="schedule-days">Dias da semana:</label>
                        <div class="days-checkboxes">
                            <label><input type="checkbox" name="schedule-day" value="0" checked> Dom</label>
                            <label><input type="checkbox" name="schedule-day" value="1" checked> Seg</label>
                            <label><input type="checkbox" name="schedule-day" value="2" checked> Ter</label>
                            <label><input type="checkbox" name="schedule-day" value="3" checked> Qua</label>
                            <label><input type="checkbox" name="schedule-day" value="4" checked> Qui</label>
                            <label><input type="checkbox" name="schedule-day" value="5" checked> Sex</label>
                            <label><input type="checkbox" name="schedule-day" value="6" checked> Sáb</label>
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label for="schedule-enabled">Ativo:</label>
                        <input type="checkbox" id="schedule-enabled" checked>
                    </div>
                    
                    <button id="add-schedule" class="btn-combine">Adicionar Agendamento</button>
                    
                    <h3 style="margin-top: 30px;">Agendamentos Ativos</h3>
                    <div class="schedules-list" id="schedules-list">
                        <p>Nenhum agendamento configurado</p>
                    </div>
                </div>
            </div>
            
            <!-- Aba de Gerenciamento -->
            <div class="tab-content" id="management-tab">
                <div class="panel">
                    <h2>Gerenciamento de Scripts</h2>
                    
                    <div class="management-controls">
                        <button id="delete-script" class="btn-danger" disabled>Excluir Script Selecionado</button>
                    </div>
                    
                    <div class="log-management">
                        <h3>Logs de Execução</h3>
                        <p>Histórico de execuções e relatórios salvos:</p>
                        
                        <div class="log-actions">
                            <button id="save-execution-log" class="save-log-btn">Salvar Log Atual</button>
                            <button id="clear-execution-logs" class="btn-danger">Limpar Logs</button>
                        </div>
                        
                        <div class="log-list" id="log-list">
                            <p>Nenhum log salvo ainda</p>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Aba de Importar/Exportar -->
            <div class="tab-content" id="import-export-tab">
                <div class="panel">
                    <h2>Importar/Exportar Scripts</h2>
                    <p>Compartilhe seus scripts entre diferentes sistemas ou faça backup:</p>
                    
                    <textarea id="json-data" class="json-viewer-textarea" placeholder="Cole aqui o JSON dos scripts ou exporte-os"></textarea>
                    
                    <div class="json-viewer-actions">
                        <button id="export-json" class="btn-execute">Exportar para JSON</button>
                        <button id="import-json" class="btn-edit">Importar de JSON</button>
                        <button id="save-json-file" class="btn-execute">Salvar como Arquivo</button>
                        <button id="load-json-file" class="btn-edit">Carregar de Arquivo</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
// Configurações globais
const API_BASE_URL = window.location.origin; // Usa o mesmo host e porta do Flask
let allCommands = []; // Lista de todos os comandos disponíveis no backend
let scripts = JSON.parse(localStorage.getItem('ir-scripts')) || []; // Armazena os scripts criados
let activeScriptIndex = null; // Índice do script sendo editado/executado
let isExecuting = false;
let executionTimeout = null;
let currentScriptCommands = []; // Comandos do script sendo editado
let executionLogs = JSON.parse(localStorage.getItem('execution-logs')) || [];
let currentExecutionLogs = [];
let activePorts = {};
let draggedCommandIndex = null;
let portExecutions = {}; // Controle de execução por porta
let schedules = JSON.parse(localStorage.getItem('ir-schedules')) || []; // Agendamentos
let scheduleCheckInterval = null; // Intervalo para verificar agendamentos
let portScriptQueues = {}; // Armazenará filas de scripts por porta

// Configurações de execução
const DEFAULT_EXECUTION_DELAY = 8000; // 5 segundos entre execuções
const PORT_RESET_DELAY = 3000; // 2 segundos para reinicialização da porta

// Elementos DOM
const sidebarScriptsContainer = document.getElementById('sidebar-scripts-container');
const statusElement = document.getElementById('status');
const jsonDataTextarea = document.getElementById('json-data');
const selectedScriptName = document.getElementById('selected-script-name');
const executeScriptBtn = document.getElementById('execute-script');
const executeMultiPortsBtn = document.getElementById('execute-multi-ports');
const loopScriptBtn = document.getElementById('loop-script');
const stopScriptBtn = document.getElementById('stop-script');
const loopCountInput = document.getElementById('loop-count');
const scriptCheckboxesContainer = document.getElementById('script-checkboxes');
const combineScriptsBtn = document.getElementById('combine-scripts');
const combinedScriptNameInput = document.getElementById('combined-script-name');
const combinedScriptDelayInput = document.getElementById('combined-script-delay');
const deleteScriptBtn = document.getElementById('delete-script');
const flowchartDisplay = document.getElementById('flowchart-display');
const executionLogsContainer = document.getElementById('execution-logs');
const scriptNameInput = document.getElementById('script-name');
const commandSelect = document.getElementById('command-select');
const commandRepeatInput = document.getElementById('command-repeat');
const commandDelayInput = document.getElementById('command-delay');
const addCommandBtn = document.getElementById('add-command');
const commandListContainer = document.getElementById('command-list');
const saveScriptBtn = document.getElementById('save-script');
const clearScriptBtn = document.getElementById('clear-script');
const progressBarFill = document.getElementById('progress-bar-fill');
const progressText = document.getElementById('progress-text');
const saveExecutionLogBtn = document.getElementById('save-execution-log');
const clearExecutionLogsBtn = document.getElementById('clear-execution-logs');
const logListContainer = document.getElementById('log-list');
const portContainer = document.getElementById('port-container');
const initializeBtn = document.getElementById('initializeBtn');
const enableAllPortsBtn = document.getElementById('enable-all-ports');
const disableAllPortsBtn = document.getElementById('disable-all-ports');
const executeAllScriptsBtn = document.getElementById('execute-all-scripts');
const stopAllExecutionsBtn = document.getElementById('stop-all-executions');
const scriptExecutionPortInput = document.getElementById('script-execution-port');
const multiExecutionPortsInput = document.getElementById('multi-execution-ports');
const scheduleScriptSelect = document.getElementById('schedule-script-select');
const schedulePortSelect = document.getElementById('schedule-port-select');
const scheduleTimeInput = document.getElementById('schedule-time');
const scheduleEnabledInput = document.getElementById('schedule-enabled');
const addScheduleBtn = document.getElementById('add-schedule');
const schedulesList = document.getElementById('schedules-list');
const globalLoader = document.getElementById('global-loader');

// Inicialização
document.addEventListener('DOMContentLoaded', function() {
    // Inicializa o controle de execução por porta e filas de scripts
    for (let i = 1; i <= 16; i++) {
        portExecutions[i] = {
            isExecuting: false,
            timeout: null,
            currentLoop: 0,
            totalLoops: 0
        };
        portScriptQueues[i] = [];
    }

    fetchCommands();
    loadScripts();
    createPorts();
    setupEventListeners();
    setupTabNavigation();
    loadSchedules();
    startScheduleChecker();
});

// Funções de comunicação com a API
async function fetchCommands() {
    try {
        showLoader(true);
        const response = await fetch(`${API_BASE_URL}/api/get-commands`);
        const data = await response.json();
        if (data.status === 'success') {
            allCommands = data.commands;
            populateCommandSelects();
        } else {
            addGlobalLog(`Erro ao buscar comandos: ${data.error}`, false);
        }
    } catch (error) {
        addGlobalLog(`Erro de rede ao buscar comandos: ${error.message}`, false);
    } finally {
        showLoader(false);
    }
}

function populateCommandSelects() {
    commandSelect.innerHTML = '<option value="">-- Selecione --</option>';
    
    // Agrupa comandos por categoria
    const commandGroups = {
        'Navegação': ['Up', 'Down', 'Left', 'Right', 'Ok','Sair'],
        'Teclas Numéricas': ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],
        'Funções': ['Power', 'Menu', 'APPS', 'Guide', 'Musica', 'VOD', 'Mute', 'Channel+', 'Vol+', 'Vol-', 'Voltar', 'Exit', 'Info'],
        'Cores': ['Red', 'Green', 'Yellow', 'Blue'],
        'Controle de Mídia': ['Play', 'Pause', 'Stop', 'Rew', 'FFwd']
    };
    
    // Preenche o select com grupos de comandos
    for (const [groupName, commands] of Object.entries(commandGroups)) {
        const optgroup = document.createElement('optgroup');
        optgroup.label = groupName;
        
        commands.forEach(cmd => {
            if (allCommands.includes(cmd)) {
                const option = document.createElement('option');
                option.value = cmd;
                option.textContent = cmd;
                optgroup.appendChild(option);
            }
        });
        
        commandSelect.appendChild(optgroup);
    }
}

async function initializeIrNetBox() {
    showStatus('Enfileirando inicialização...', 'info');
    try {
        showLoader(true);
        const response = await fetch(`${API_BASE_URL}/api/initialize`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' }
        });
        const data = await response.json();
        if (data.success) {
            showStatus(data.message, 'success');
            addGlobalLog(data.message, true);
        } else {
            showStatus(`Erro: ${data.error}`, 'error');
            addGlobalLog(`Erro na inicialização: ${data.error}`, false);
        }
    } catch (error) {
        showStatus(`Erro de rede: ${error.message}`, 'error');
        addGlobalLog(`Erro de rede na inicialização: ${error.message}`, false);
    } finally {
        showLoader(false);
    }
}

async function sendCommand(command, port) {
    addExecutionLog(`Enviando comando '${command}' para porta ${port}...`);
    try {
        showLoader(true);
        const response = await fetch(`${API_BASE_URL}/api/send-command`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ command, port })
        });
        const data = await response.json();
        if (data.success) {
            addExecutionLog(`Comando '${command}' para porta ${port} enfileirado com sucesso.`, true);
            return true;
        } else {
            addExecutionLog(`Erro ao enfileirar comando '${command}' para porta ${port}: ${data.error}`, false);
            throw new Error(data.error);
        }
    } catch (error) {
        addExecutionLog(`Erro de rede ao enviar comando '${command}' para porta ${port}: ${error.message}`, false);
        throw error;
    } finally {
        showLoader(false);
    }
}

async function sendMultiPortCommand(command, ports) {
    addExecutionLog(`Enviando comando '${command}' para portas ${ports.join(', ')}...`);
    try {
        showLoader(true);
        const response = await fetch(`${API_BASE_URL}/api/execute-multiple-ports`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ command, ports })
        });
        const data = await response.json();
        if (data.success) {
            addExecutionLog(`Comando '${command}' para portas ${ports.join(', ')} enfileirado com sucesso.`, true);
            return true;
        } else {
            addExecutionLog(`Erro ao enfileirar comando '${command}' para portas ${ports.join(', ')}: ${data.error}`, false);
            throw new Error(data.error);
        }
    } catch (error) {
        addExecutionLog(`Erro de rede ao enviar comando '${command}' para portas ${ports.join(', ')}: ${error.message}`, false);
        throw error;
    } finally {
        showLoader(false);
    }
}

// Funções de gerenciamento de scripts
function loadScripts() {
    sidebarScriptsContainer.innerHTML = '';
    scriptCheckboxesContainer.innerHTML = '';
    
    if (scripts.length === 0) {
        sidebarScriptsContainer.innerHTML = '<p style="text-align: center; color: rgba(255,255,255,0.7);">Nenhum script salvo ainda</p>';
        scriptCheckboxesContainer.innerHTML = '<p>Nenhum script disponível para combinação</p>';
        updateFlowchartDisplay();
        return;
    }
    
    // Carrega scripts na sidebar
    scripts.forEach((script, index) => {
        const scriptElement = document.createElement('div');
        scriptElement.className = `sidebar-script-item ${activeScriptIndex === index ? 'active' : ''}`;
        scriptElement.dataset.index = index;
        
        scriptElement.innerHTML = `
            <div class="script-name">${script.name} <span style="font-size: 0.8em; opacity: 0.7;">(${script.commands.length} cmd)</span></div>
            <div class="script-actions">
                <button class="btn-execute" data-index="${index}">Executar</button>
                <button class="btn-edit" data-index="${index}">Editar</button>
                <button class="btn-danger" data-index="${index}">Excluir</button>
            </div>
        `;
        
        sidebarScriptsContainer.appendChild(scriptElement);
    });
    
    // Carrega checkboxes para combinação
    scripts.forEach((script, index) => {
        const checkboxItem = document.createElement('div');
        checkboxItem.className = 'script-checkbox-item';
        
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.id = `script-${index}`;
        checkbox.value = index;
        checkbox.addEventListener('change', updateFlowchartDisplay);
        
        const label = document.createElement('label');
        label.htmlFor = `script-${index}`;
        label.textContent = script.name;
        
        checkboxItem.appendChild(checkbox);
        checkboxItem.appendChild(label);
        scriptCheckboxesContainer.appendChild(checkboxItem);
    });
    
    updateFlowchartDisplay();
    
    // Atualiza os selects das portas
    updatePortScriptSelects();
}

function saveScriptsToStorage() {
    localStorage.setItem('ir-scripts', JSON.stringify(scripts));
}

function saveSchedulesToStorage() {
    localStorage.setItem('ir-schedules', JSON.stringify(schedules));
}

function saveLogsToStorage() {
    localStorage.setItem('execution-logs', JSON.stringify(executionLogs));
}

function renderCommandList() {
    commandListContainer.innerHTML = '';
    
    if (currentScriptCommands.length === 0) {
        commandListContainer.innerHTML = '<p style="text-align: center; color: #999;">Nenhum comando adicionado ainda</p>';
        return;
    }
    
    currentScriptCommands.forEach((cmd, index) => {
        const cmdElement = document.createElement('div');
        cmdElement.className = 'command-item';
        cmdElement.dataset.index = index;
        cmdElement.draggable = true;
        
        cmdElement.innerHTML = `
            <div class="command-details">
                <div class="command-name">${cmd.command}</div>
                <div class="command-props">Repetir: ${cmd.repeat}x | Atraso: ${cmd.delay}ms</div>
            </div>
            <button class="btn-danger" data-index="${index}">Remover</button>
        `;
        
        cmdElement.querySelector('button').addEventListener('click', (e) => {
            e.stopPropagation();
            const cmdIndex = parseInt(e.target.getAttribute('data-index'));
            currentScriptCommands.splice(cmdIndex, 1);
            renderCommandList();
            showStatus('Comando removido.', 'info');
        });
        
        // Adiciona eventos de drag and drop
        cmdElement.addEventListener('dragstart', handleCommandDragStart);
        cmdElement.addEventListener('dragover', handleCommandDragOver);
        cmdElement.addEventListener('drop', handleCommandDrop);
        cmdElement.addEventListener('dragend', handleCommandDragEnd);
        
        commandListContainer.appendChild(cmdElement);
    });
}

function selectScript(index) {
    document.querySelectorAll('.sidebar-script-item').forEach(item => {
        item.classList.remove('active');
    });
    
    sidebarScriptsContainer.children[index].classList.add('active');
    activeScriptIndex = index;
    
    // Atualiza o painel de execução
    const script = scripts[index];
    selectedScriptName.textContent = script.name;
    
    // Habilita os botões de execução
    executeScriptBtn.disabled = false;
    executeMultiPortsBtn.disabled = false;
    loopScriptBtn.disabled = false;
    deleteScriptBtn.disabled = false;
    stopScriptBtn.disabled = isExecuting ? false : true;
}

function editScript(index) {
    const script = scripts[index];
    activeScriptIndex = index;
    
    // Preenche o formulário com os dados do script
    scriptNameInput.value = script.name;
    currentScriptCommands = [...script.commands];
    
    // Renderiza a lista de comandos
    renderCommandList();
    
    // Atualiza a aba ativa para o editor
    document.querySelector('.tab[data-tab="editor"]').click();
    
    showStatus(`Editando script "${script.name}"`, 'info');
}

function createScript() {
    const name = scriptNameInput.value.trim();
    if (!name) {
        alert('Por favor, insira um nome para o script.');
        return;
    }
    
    const newScript = { name: name, commands: currentScriptCommands };
    scripts.push(newScript);
    activeScriptIndex = scripts.length - 1;
    saveScriptsToStorage();
    loadScripts();
    editScript(activeScriptIndex);
    showStatus(`Script "${name}" criado com sucesso!`, 'success');
}

function updateFlowchartDisplay() {
    flowchartDisplay.innerHTML = '';
    const checkboxes = scriptCheckboxesContainer.querySelectorAll('input[type="checkbox"]:checked');
    
    if (checkboxes.length === 0) {
        flowchartDisplay.innerHTML = '<p style="color: #666;">Selecione scripts para ver a sequência de comandos.</p>';
        return;
    }
    
    // Coleta todos os comandos dos scripts selecionados
    let allCommands = [];
    checkboxes.forEach(checkbox => {
        const scriptIndex = parseInt(checkbox.value);
        allCommands = allCommands.concat(scripts[scriptIndex].commands);
    });
    
    // Exibe a sequência de comandos
    if (allCommands.length > 0) {
        let html = '<div style="width: 100%;">';
        html += '<p><strong>Sequência de Comandos:</strong></p>';
        html += '<div style="display: flex; flex-wrap: wrap; gap: 8px;">';
        
        allCommands.forEach((cmd, index) => {
            html += `<div class="flowchart-node">${cmd.command} (${cmd.repeat}x)</div>`;
            if (index < allCommands.length - 1) {
                html += '<div class="flowchart-arrow">→</div>';
            }
        });
        
        html += '</div></div>';
        flowchartDisplay.innerHTML = html;
    } else {
        flowchartDisplay.innerHTML = '<p>Nenhum comando nos scripts selecionados.</p>';
    }
}

function combineScripts() {
    const selectedScriptsIndexes = [];
    const checkboxes = scriptCheckboxesContainer.querySelectorAll('input[type="checkbox"]:checked');
    
    if (checkboxes.length < 2) {
        showStatus('Selecione pelo menos 2 scripts para combinar', 'error');
        return;
    }
    
    const newScriptName = combinedScriptNameInput.value.trim();
    if (!newScriptName) {
        showStatus('Digite um nome para o novo script combinado', 'error');
        return;
    }
    
    checkboxes.forEach(checkbox => {
        selectedScriptsIndexes.push(parseInt(checkbox.value));
    });
    
    // Cria uma nova lista de comandos baseada na ordem de seleção no HTML
    const combinedCommands = [];
    selectedScriptsIndexes.forEach(index => {
        combinedCommands.push(...scripts[index].commands);
    });
    
    const newScript = {
        name: newScriptName,
        commands: combinedCommands
    };
    
    scripts.push(newScript);
    saveScriptsToStorage();
    loadScripts();
    showStatus(`Script combinado "${newScriptName}" criado com sucesso!`, 'success');
    combinedScriptNameInput.value = '';
    
    // Desmarca todas as checkboxes após a combinação
    checkboxes.forEach(checkbox => {
        checkbox.checked = false;
    });
    
    updateFlowchartDisplay();
}

// Funções de execução de scripts
async function executeScript(index, port = 1) {
    if (portExecutions[port].isExecuting) return;
    
    portExecutions[port].isExecuting = true;
    portExecutions[port].currentLoop = 0;
    portExecutions[port].totalLoops = 1;
    
    const script = scripts[index];
    clearExecutionLogs();
    addExecutionLog(`Iniciando execução do script: ${script.name} na porta ${port}`);
    
    try {
        const totalCommands = script.commands.reduce((sum, cmd) => sum + cmd.repeat, 0);
        let commandsExecuted = 0;
        
        for (let i = 0; i < script.commands.length; i++) {
            const cmd = script.commands[i];
            
            for (let j = 0; j < cmd.repeat; j++) {
                if (!portExecutions[port].isExecuting) break;
                
                commandsExecuted++;
                const progress = Math.round((commandsExecuted / totalCommands) * 100);
                updateProgressBar(progress);
                
                await sendCommand(cmd.command, port);
                
                if (j < cmd.repeat - 1 && cmd.delay && cmd.delay > 0) {
                    await new Promise(resolve => {
                        portExecutions[port].timeout = setTimeout(resolve, cmd.delay);
                    });
                }
            }
            
            if (!portExecutions[port].isExecuting) break;
            
            // Atraso entre comandos
            if (cmd.delay && cmd.delay > 0 && i < script.commands.length - 1) {
                await new Promise(resolve => {
                    portExecutions[port].timeout = setTimeout(resolve, cmd.delay);
                });
            }
        }
        
        if (portExecutions[port].isExecuting) {
            addExecutionLog(`Script "${script.name}" concluído com sucesso na porta ${port}!`, true);
            showStatus(`Script "${script.name}" concluído na porta ${port}!`, 'success');
        } else {
            addExecutionLog(`Execução do script "${script.name}" interrompida.`, false);
        }
    } catch (error) {
        addExecutionLog(`Erro durante a execução: ${error.message}`);
        showStatus(`Erro durante a execução: ${error.message}`, 'error');
    } finally {
        portExecutions[port].isExecuting = false;
        portExecutions[port].timeout = null;
        updatePortExecutionStatus(port, false);
        updateProgressBar(0);
    }
}

async function executeScriptLoop(index, loopCount, port = 1) {
    if (portExecutions[port].isExecuting) return;
    
    portExecutions[port].isExecuting = true;
    portExecutions[port].currentLoop = 0;
    portExecutions[port].totalLoops = loopCount;
    
    const script = scripts[index];
    clearExecutionLogs();
    addExecutionLog(`Iniciando execução em loop (${loopCount}x) do script: ${script.name} na porta ${port}`);
    
    try {
        for (let loop = 0; loop < loopCount; loop++) {
            if (!portExecutions[port].isExecuting) break;
            
            portExecutions[port].currentLoop = loop + 1;
            addExecutionLog(`Iniciando loop ${portExecutions[port].currentLoop}/${loopCount}`);
            
            const totalCommands = script.commands.reduce((sum, cmd) => sum + cmd.repeat, 0);
            let commandsExecuted = 0;
            
            for (let i = 0; i < script.commands.length; i++) {
                const cmd = script.commands[i];
                
                for (let j = 0; j < cmd.repeat; j++) {
                    if (!portExecutions[port].isExecuting) break;
                    
                    commandsExecuted++;
                    const progress = Math.round((commandsExecuted / totalCommands) * 100);
                    updateProgressBar(progress);
                    
                    await sendCommand(cmd.command, port);
                    
                    if (j < cmd.repeat - 1 && cmd.delay && cmd.delay > 0) {
                        await new Promise(resolve => {
                            portExecutions[port].timeout = setTimeout(resolve, cmd.delay);
                        });
                    }
                }
                
                if (!portExecutions[port].isExecuting) break;
                
                // Atraso entre comandos
                if (cmd.delay && cmd.delay > 0 && i < script.commands.length - 1) {
                    await new Promise(resolve => {
                        portExecutions[port].timeout = setTimeout(resolve, cmd.delay);
                    });
                }
            }
            
            if (!portExecutions[port].isExecuting) break;
            
            if (loop < loopCount - 1) {
                await new Promise(resolve => {
                    portExecutions[port].timeout = setTimeout(resolve, 1200);
                });
            }
        }
        
        if (portExecutions[port].isExecuting) {
            addExecutionLog(`Loop do script "${script.name}" concluído (${loopCount} execuções)!`, true);
            showStatus(`Loop do script "${script.name}" concluído (${loopCount} execuções)!`, 'success');
        } else {
            addExecutionLog(`Execução em loop interrompida.`, false);
        }
    } catch (error) {
        addExecutionLog(`Erro durante a execução em loop: ${error.message}`);
        showStatus(`Erro durante a execução em loop: ${error.message}`, 'error');
    } finally {
        portExecutions[port].isExecuting = false;
        portExecutions[port].timeout = null;
        updatePortExecutionStatus(port, false);
        updateProgressBar(0);
    }
}

// Função para executar scripts em sequência em uma porta
async function executeScriptQueueOnPort(port) {
    if (portExecutions[port].isExecuting) return;
    
    const portCard = document.querySelector(`.port-card[data-port="${port}"]`);
    if (!portCard) return;
    
    try {
        portCard.classList.add('executing');
        portCard.classList.remove('error', 'success');
        updatePortExecutionStatus(port, true);
        
        while (portScriptQueues[port].length > 0 && portExecutions[port].isExecuting) {
            const { scriptIndex, loopCount } = portScriptQueues[port][0];
            const script = scripts[scriptIndex];
            
            logToPort(port, `Iniciando execução do script: "${script.name}"`);
            
            if (loopCount > 1) {
                await executeScriptLoopOnPort(port, scriptIndex, loopCount);
            } else {
                await executeScriptOnPort(port, scriptIndex);
            }
            
            // Remove o script da fila após execução
            portScriptQueues[port].shift();
            updateQueueDisplay(port);
        }
        
        if (portExecutions[port].isExecuting) {
            logToPort(port, 'Todos os scripts da fila foram executados com sucesso!', 'success');
        } else {
            logToPort(port, 'Execução interrompida pelo usuário', 'warning');
        }
    } catch (error) {
        logToPort(port, `Erro durante a execução: ${error.message}`, 'error');
    } finally {
        updatePortExecutionStatus(port, false);
        portCard.classList.remove('executing');
    }
}

function updateQueueDisplay(port) {
    const portCard = document.querySelector(`.port-card[data-port="${port}"]`);
    if (portCard) {
        const queueCount = portCard.querySelector('.queue-count');
        if (queueCount) {
            queueCount.textContent = portScriptQueues[port].length;
        }
    }
}

function stopExecution() {
    if (isExecuting) {
        isExecuting = false;
        if (executionTimeout) {
            clearTimeout(executionTimeout);
            executionTimeout = null;
        }
        addExecutionLog('Execução interrompida pelo usuário.', false);
        showStatus('Execução interrompida.', 'warning');
    }
}

function stopPortExecution(port) {
    if (portExecutions[port].isExecuting) {
        portExecutions[port].isExecuting = false;
        if (portExecutions[port].timeout) {
            clearTimeout(portExecutions[port].timeout);
            portExecutions[port].timeout = null;
        }
        
        // Limpa a fila de scripts
        portScriptQueues[port] = [];
        updateQueueDisplay(port);
        
        logToPort(port, 'Execução interrompida pelo usuário. Fila de scripts limpa.', 'warning');
        updatePortExecutionStatus(port, false);
        
        // Restaura o botão de ativar porta
        const portCard = document.querySelector(`.port-card[data-port="${port}"]`);
        if (portCard) {
            const activateButton = portCard.querySelector('.port-activate');
            if (activateButton) {
                activateButton.style.display = 'block';
            }
        }
    }
}

// Funções de execução em portas
async function executeScriptOnPort(port, scriptIndex) {
    if (portExecutions[port].isExecuting) return;
    
    const portCard = document.querySelector(`.port-card[data-port="${port}"]`);
    if (!portCard) {
        console.error(`Elemento da porta ${port} não encontrado`);
        return;
    }
    
    try {
        portCard.classList.add('executing');
        portCard.classList.remove('error', 'success');
        updatePortExecutionStatus(port, true);
        
        logToPort(port, `Iniciando execução do script "${scripts[scriptIndex].name}"`);
        
        // Executa o script
        await executeScript(scriptIndex, port);
        
        // Adiciona atraso padrão antes da reinicialização
        await new Promise(resolve => {
            portExecutions[port].timeout = setTimeout(resolve, DEFAULT_EXECUTION_DELAY);
        });
        
        // Reinicializa a porta após a execução
        logToPort(port, 'Reinicializando porta após execução...');
        await initializePortAfterExecution(port);
        
        portCard.classList.remove('executing');
        portCard.classList.add('success');
        logToPort(port, `Script "${scripts[scriptIndex].name}" executado com sucesso e porta reinicializada`, 'success');
    } catch (error) {
        portCard.classList.remove('executing');
        portCard.classList.add('error');
        logToPort(port, `Erro ao executar script: ${error.message}`, 'error');
        
        // Tenta reinicializar mesmo em caso de erro
        try {
            await initializePortAfterExecution(port);
        } catch (err) {
            logToPort(port, `Erro ao reinicializar porta: ${err.message}`, 'error');
        }
    } finally {
        updatePortExecutionStatus(port, false);
    }
}

async function executeScriptLoopOnPort(port, scriptIndex, loopCount) {
    if (portExecutions[port].isExecuting) return;
    
    const portCard = document.querySelector(`.port-card[data-port="${port}"]`);
    if (!portCard) {
        console.error(`Elemento da porta ${port} não encontrado`);
        return;
    }
    
    try {
        portCard.classList.add('executing');
        portCard.classList.remove('error', 'success');
        updatePortExecutionStatus(port, true);
        
        logToPort(port, `Iniciando execução em loop (${loopCount}x) do script "${scripts[scriptIndex].name}"`);
        
        for (let i = 0; i < loopCount; i++) {
            if (!portExecutions[port].isExecuting) break;
            
            portExecutions[port].currentLoop = i + 1;
            logToPort(port, `Iniciando loop ${portExecutions[port].currentLoop}/${loopCount}`);
            
            // Executa o script
            await executeScript(scriptIndex, port);
            
            // Adiciona atraso padrão antes da reinicialização (exceto no último loop)
            if (i < loopCount - 1) {
                await new Promise(resolve => {
                    portExecutions[port].timeout = setTimeout(resolve, DEFAULT_EXECUTION_DELAY);
                });
                
                // Reinicializa a porta após cada execução (exceto a última)
                logToPort(port, 'Reinicializando porta após execução...');
                await initializePortAfterExecution(port);
            }
        }
        
        portCard.classList.remove('executing');
        portCard.classList.add('success');
        logToPort(port, `Loop do script "${scripts[scriptIndex].name}" concluído (${loopCount} execuções)!`, 'success');
    } catch (error) {
        portCard.classList.remove('executing');
        portCard.classList.add('error');
        logToPort(port, `Erro ao executar script em loop: ${error.message}`, 'error');
        
        // Tenta reinicializar mesmo em caso de erro
        try {
            await initializePortAfterExecution(port);
        } catch (err) {
            logToPort(port, `Erro ao reinicializar porta: ${err.message}`, 'error');
        }
    } finally {
        updatePortExecutionStatus(port, false);
    }
}

// Nova função para reinicializar a porta
async function initializePortAfterExecution(port) {
    try {
        showLoader(true);
        logToPort(port, `Iniciando reinicialização da porta ${port}...`);
        
        const response = await fetch(`${API_BASE_URL}/api/initialize`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ port })
        });
        
        const data = await response.json();
        if (data.success) {
            logToPort(port, 'Porta reinicializada com sucesso', 'success');
            return true;
        } else {
            throw new Error(data.error || 'Erro desconhecido ao reinicializar porta');
        }
    } catch (error) {
        logToPort(port, `Erro ao reinicializar porta: ${error.message}`, 'error');
        throw error;
    } finally {
        showLoader(false);
    }
}

// Função modificada para execução em múltiplas portas com reinicialização
async function executeScriptOnMultiplePorts(index, ports) {
    if (isExecuting) return;
    
    isExecuting = true;
    stopScriptBtn.disabled = false;
    const script = scripts[index];
    clearExecutionLogs();
    addExecutionLog(`Iniciando execução do script: ${script.name} em múltiplas portas: ${ports.join(', ')}`);
    
    executeScriptBtn.disabled = true;
    executeMultiPortsBtn.disabled = true;
    loopScriptBtn.disabled = true;
    deleteScriptBtn.disabled = true;
    
    try {
        const totalCommands = script.commands.length * ports.length;
        let commandsExecuted = 0;
        
        for (const port of ports) {
            if (!isExecuting) break;
            
            const portCard = document.querySelector(`.port-card[data-port="${port}"]`);
            if (portCard) {
                portCard.classList.add('executing');
                updatePortExecutionStatus(port, true);
            }
            
            addExecutionLog(`Iniciando execução na porta ${port}`);
            
            for (let i = 0; i < script.commands.length; i++) {
                const cmd = script.commands[i];
                
                commandsExecuted++;
                const progress = Math.round((commandsExecuted / totalCommands) * 100);
                updateProgressBar(progress);
                
                await sendCommand(cmd.command, port);
                
                if (cmd.delay && cmd.delay > 0 && i < script.commands.length - 1) {
                    await new Promise(resolve => {
                        executionTimeout = setTimeout(resolve, cmd.delay);
                    });
                }
            }
            
            // Adiciona atraso padrão antes da reinicialização
            await new Promise(resolve => {
                executionTimeout = setTimeout(resolve, DEFAULT_EXECUTION_DELAY);
            });
            
            // Reinicializa a porta após a execução
            addExecutionLog(`Reinicializando porta ${port} após execução...`);
            try {
                await initializePortAfterExecution(port);
                addExecutionLog(`Porta ${port} reinicializada com sucesso`, true);
            } catch (error) {
                addExecutionLog(`Erro ao reinicializar porta ${port}: ${error.message}`, false);
            }
            
            if (portCard) {
                portCard.classList.remove('executing');
                updatePortExecutionStatus(port, false);
            }
        }
        
        if (isExecuting) {
            addExecutionLog(`Script "${script.name}" concluído com sucesso em múltiplas portas!`, true);
            showStatus(`Script "${script.name}" concluído em múltiplas portas!`, 'success');
        } else {
            addExecutionLog(`Execução do script "${script.name}" interrompida.`, false);
        }
    } catch (error) {
        addExecutionLog(`Erro durante a execução: ${error.message}`);
        showStatus(`Erro durante a execução: ${error.message}`, 'error');
    } finally {
        isExecuting = false;
        stopScriptBtn.disabled = true;
        executeScriptBtn.disabled = false;
        executeMultiPortsBtn.disabled = false;
        loopScriptBtn.disabled = false;
        deleteScriptBtn.disabled = false;
        updateProgressBar(0);
    }
}

// Funções de UI
function showStatus(message, type = 'info') {
    statusElement.textContent = message;
    statusElement.className = 'status';
    statusElement.classList.add(type);
    
    setTimeout(() => {
        if (statusElement.textContent === message) {
            statusElement.textContent = '';
            statusElement.className = 'status';
        }
    }, 5000);
}

function addExecutionLog(message, isSuccess = false) {
    const timestamp = new Date().toLocaleTimeString();
    const logItem = document.createElement('div');
    logItem.className = 'execution-log-item';
    
    logItem.innerHTML = `
        <span class="execution-log-timestamp">[${timestamp}]</span>
        <span class="execution-log-command ${isSuccess ? 'execution-log-success' : ''}">${message}</span>
    `;
    
    if (executionLogsContainer.firstChild && executionLogsContainer.firstChild.nodeName === 'P') {
        executionLogsContainer.removeChild(executionLogsContainer.firstChild);
    }
    
    executionLogsContainer.appendChild(logItem);
    executionLogsContainer.scrollTop = executionLogsContainer.scrollHeight;
    
    currentExecutionLogs.push({
        timestamp: new Date().toISOString(),
        message,
        isSuccess
    });
    
    if (executionLogsContainer.children.length > 100) {
        executionLogsContainer.removeChild(executionLogsContainer.children[0]);
    }
}

function clearExecutionLogs() {
    executionLogsContainer.innerHTML = '<p>Nenhum log de execução disponível</p>';
    currentExecutionLogs = [];
}

function updateProgressBar(percent) {
    progressBarFill.style.width = `${percent}%`;
    progressText.textContent = `${percent}%`;
}

function addGlobalLog(message, isSuccess = false) {
    addExecutionLog(message, isSuccess);
}

// Função para criar as portas na interface
function createPorts() {
    portContainer.innerHTML = '';
    
    for (let i = 1; i <= 16; i++) {
        const portCard = document.createElement('div');
        portCard.className = 'port-card';
        portCard.dataset.port = i;
        
        portCard.innerHTML = `
            <div class="port-header">
                <div class="port-title">
                    <span class="port-number">${i}</span>
                    Porta ${i}
                </div>
                <span class="port-status inactive">Inativa</span>
            </div>
            
            <div class="port-controls">
                <select class="port-select port-script-select" multiple style="height: 100px;">
                    ${scripts.map((script, idx) => 
                        `<option value="${idx}">${script.name}</option>`
                    ).join('')}
                </select>
                
                <div class="port-loop-controls" style="display: flex; gap: 5px; margin-bottom: 8px;">
                    <input type="number" class="port-loop-count" min="1" value="1" placeholder="Loops" style="flex: 1;">
                    <button class="port-button port-execute-loop" data-port="${i}">
                        Executar em Loop
                    </button>
                </div>
                
                <button class="port-button port-execute" data-port="${i}">
                    Executar Scripts
                </button>
                
                <button class="port-button secondary port-activate" data-port="${i}">
                    Ativar Porta
                </button>
                
                <button class="port-button btn-stop port-stop" data-port="${i}" style="display: none;">
                    Parar Execução
                </button>
                
                <div class="port-queue-info" style="margin-top: 8px; font-size: 0.8rem; color: #666;">
                    Scripts na fila: <span class="queue-count">0</span>
                </div>
            </div>
            
            <div class="port-log" id="port-log-${i}">
                <div class="log-entry">
                    <span class="log-time">[${new Date().toLocaleTimeString()}]</span>
                    Porta criada e pronta para uso
                </div>
            </div>
        `;
        
        portContainer.appendChild(portCard);
    }
}

function updateScriptSelect(selectElement) {
    // Salva o valor atualmente selecionado
    const currentValue = selectElement.value;
    
    // Limpa as opções
    selectElement.innerHTML = '';
    
    // Adiciona os scripts
    scripts.forEach((script, index) => {
        const option = document.createElement('option');
        option.value = index;
        option.textContent = script.name;
        selectElement.appendChild(option);
    });
    
    // Restaura o valor selecionado, se ainda existir
    if (currentValue && scripts[currentValue]) {
        selectElement.value = currentValue;
    }
}

function updatePortScriptSelects() {
    document.querySelectorAll('.port-script-select').forEach(select => {
        updateScriptSelect(select);
    });
    
    // Atualiza também o select de scripts na aba de agendamento
    if (scheduleScriptSelect) {
        updateScriptSelect(scheduleScriptSelect);
    }
}

function updatePortStatus(port, status, text) {
    const statusElement = document.querySelector(`.port-card[data-port="${port}"] .port-status`);
    if (statusElement) {
        statusElement.className = `port-status ${status}`;
        statusElement.textContent = text;
    }
}

function updatePortExecutionStatus(port, isExecuting) {
    const portCard = document.querySelector(`.port-card[data-port="${port}"]`);
    if (!portCard) return;
    
    const executeBtn = portCard.querySelector('.port-execute');
    const executeLoopBtn = portCard.querySelector('.port-execute-loop');
    const stopBtn = portCard.querySelector('.port-stop');
    
    if (isExecuting) {
        portCard.classList.add('executing');
        portCard.classList.remove('error', 'success');
        if (executeBtn) executeBtn.disabled = true;
        if (executeLoopBtn) executeLoopBtn.disabled = true;
        if (executeBtn) executeBtn.style.display = 'none';
        if (executeLoopBtn) executeLoopBtn.style.display = 'none';
        if (stopBtn) stopBtn.style.display = 'block';
        updatePortStatus(port, 'executing', 'Executando');
    } else {
        portCard.classList.remove('executing');
        if (executeBtn) executeBtn.disabled = false;
        if (executeLoopBtn) executeLoopBtn.disabled = false;
        if (executeBtn) executeBtn.style.display = 'block';
        if (executeLoopBtn) executeLoopBtn.style.display = 'block';
        if (stopBtn) stopBtn.style.display = 'none';
        updatePortStatus(port, portCard.classList.contains('active') ? 'active' : 'inactive', 
                        portCard.classList.contains('active') ? 'Ativa' : 'Inativa');
    }
}

function logToPort(port, message, type = 'info') {
    const logElement = document.getElementById(`port-log-${port}`);
    if (!logElement) return;
    
    const timestamp = new Date().toLocaleTimeString();
    const logEntry = document.createElement('div');
    logEntry.className = 'log-entry';
    
    logEntry.innerHTML = `
        <span class="log-time">[${timestamp}]</span>
        ${message}
    `;
    
    if (type === 'error') {
        logEntry.style.color = 'var(--port-error)';
    } else if (type === 'success') {
        logEntry.style.color = 'var(--port-success)';
    } else if (type === 'warning') {
        logEntry.style.color = 'var(--warning-color)';
    }
    
    logElement.prepend(logEntry);
    
    while (logElement.children.length > 50) {
        logElement.removeChild(logElement.lastChild);
    }
}

// Funções de agendamento
function loadSchedules() {
    schedulesList.innerHTML = '';
    
    if (schedules.length === 0) {
        schedulesList.innerHTML = '<p>Nenhum agendamento configurado</p>';
        return;
    }
    
    // Preenche o select de portas para agendamento
    populatePortSelects();
    
    // Ordena os agendamentos por horário
    schedules.sort((a, b) => {
        const timeA = a.time.split(':').map(Number);
        const timeB = b.time.split(':').map(Number);
        return timeA[0] - timeB[0] || timeA[1] - timeB[1];
    });
    
    // Exibe os agendamentos
    schedules.forEach((schedule, index) => {
        const scheduleItem = document.createElement('div');
        scheduleItem.className = 'schedule-item';
        scheduleItem.dataset.index = index;
        
        const daysMap = ['Dom', 'Seg', 'Ter', 'Qua', 'Qui', 'Sex', 'Sáb'];
        const activeDays = schedule.days.map(day => daysMap[day]).join(', ');
        
        scheduleItem.innerHTML = `
            <div class="schedule-header">
                <span class="schedule-time">${schedule.time}</span>
                <span class="schedule-status ${schedule.enabled ? 'active' : 'inactive'}">
                    ${schedule.enabled ? 'Ativo' : 'Inativo'}
                </span>
            </div>
            <div class="schedule-details">
                <div><strong>Script:</strong> ${scripts[schedule.scriptIndex].name}</div>
                <div><strong>Porta:</strong> ${schedule.port}</div>
                <div><strong>Dias:</strong> ${activeDays}</div>
            </div>
            <div class="schedule-actions">
                <button class="btn-edit edit-schedule" data-index="${index}">Editar</button>
                <button class="btn-danger delete-schedule" data-index="${index}">Excluir</button>
                <button class="btn-execute execute-now" data-index="${index}">Executar Agora</button>
            </div>
        `;
        
        schedulesList.appendChild(scheduleItem);
    });
}

function populatePortSelects() {
    schedulePortSelect.innerHTML = '<option value="">Selecione uma porta...</option>';
    for (let i = 1; i <= 16; i++) {
        const option = document.createElement('option');
        option.value = i;
        option.textContent = `Porta ${i}`;
        schedulePortSelect.appendChild(option);
    }
}

function startScheduleChecker() {
    // Verifica a cada minuto se há agendamentos para executar
    if (scheduleCheckInterval) {
        clearInterval(scheduleCheckInterval);
    }
    
    scheduleCheckInterval = setInterval(checkSchedules, 60000); // 1 minuto
    checkSchedules(); // Verifica imediatamente ao carregar
}

function checkSchedules() {
    const now = new Date();
    const currentHours = now.getHours().toString().padStart(2, '0');
    const currentMinutes = now.getMinutes().toString().padStart(2, '0');
    const currentTime = `${currentHours}:${currentMinutes}`;
    const currentDay = now.getDay(); // 0=Domingo, 1=Segunda, etc.
    
    schedules.forEach(schedule => {
        if (!schedule.enabled) return;
        
        // Verifica se é o horário e dia correto
        if (schedule.time === currentTime && schedule.days.includes(currentDay)) {
            // Verifica se já executou hoje
            const lastRun = schedule.lastRun ? new Date(schedule.lastRun) : null;
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            
            if (!lastRun || lastRun < today) {
                // Executa o script na porta agendada
                executeScriptOnPort(schedule.port, schedule.scriptIndex);
                
                // Atualiza a data da última execução
                schedule.lastRun = new Date().toISOString();
                saveSchedulesToStorage();
                
                // Log da execução agendada
                const scriptName = scripts[schedule.scriptIndex].name;
                addGlobalLog(`Execução agendada: ${scriptName} na porta ${schedule.port} às ${currentTime}`, true);
                
                // Mostra notificação
                showNotification(`Execução agendada: ${scriptName} na porta ${schedule.port}`, 'success');
            }
        }
    });
}

function saveSchedule() {
    const scriptIndex = scheduleScriptSelect.value;
    const port = schedulePortSelect.value;
    const time = scheduleTimeInput.value;
    const enabled = scheduleEnabledInput.checked;
    
    if (!scriptIndex || !port || !time) {
        showStatus('Preencha todos os campos obrigatórios', 'error');
        showNotification('Preencha todos os campos obrigatórios', 'error');
        return;
    }
    
    // Obtém os dias selecionados
    const dayCheckboxes = document.querySelectorAll('input[name="schedule-day"]:checked');
    const days = Array.from(dayCheckboxes).map(cb => parseInt(cb.value));
    
    if (days.length === 0) {
        showStatus('Selecione pelo menos um dia da semana', 'error');
        showNotification('Selecione pelo menos um dia da semana', 'error');
        return;
    }
    
    const newSchedule = {
        scriptIndex: parseInt(scriptIndex),
        port: parseInt(port),
        time,
        days,
        enabled,
        lastRun: null
    };
    
    schedules.push(newSchedule);
    saveSchedulesToStorage();
    
    showStatus('Agendamento adicionado com sucesso!', 'success');
    showNotification('Agendamento adicionado com sucesso!', 'success');
    loadSchedules();
    
    // Limpa o formulário
    scheduleScriptSelect.value = '';
    schedulePortSelect.value = '';
    scheduleTimeInput.value = '';
    scheduleEnabledInput.checked = true;
    document.querySelectorAll('input[name="schedule-day"]').forEach(cb => cb.checked = true);
}

function editSchedule(index) {
    const schedule = schedules[index];
    
    // Preenche o formulário com os dados do agendamento
    scheduleScriptSelect.value = schedule.scriptIndex;
    schedulePortSelect.value = schedule.port;
    scheduleTimeInput.value = schedule.time;
    scheduleEnabledInput.checked = schedule.enabled;
    
    // Marca os dias selecionados
    document.querySelectorAll('input[name="schedule-day"]').forEach(cb => {
        cb.checked = schedule.days.includes(parseInt(cb.value));
    });
    
    // Remove o agendamento antigo
    schedules.splice(index, 1);
    
    // Rola até o formulário
    document.querySelector('.tab[data-tab="scheduling"]').click();
    scheduleScriptSelect.focus();
    
    showStatus('Editando agendamento. Preencha os campos e clique em "Adicionar Agendamento" para salvar.', 'info');
    showNotification('Editando agendamento. Preencha os campos e clique em "Adicionar Agendamento" para salvar.', 'info');
}

function deleteSchedule(index) {
    if (confirm('Tem certeza que deseja excluir este agendamento?')) {
        schedules.splice(index, 1);
        saveSchedulesToStorage();
        loadSchedules();
        showStatus('Agendamento excluído com sucesso!', 'success');
        showNotification('Agendamento excluído com sucesso!', 'success');
    }
}

function executeScheduleNow(index) {
    const schedule = schedules[index];
    executeScriptOnPort(schedule.port, schedule.scriptIndex);
    showStatus(`Executando script agendado agora na porta ${schedule.port}`, 'info');
    showNotification(`Executando script agendado agora na porta ${schedule.port}`, 'info');
}

// Funções auxiliares
function showLoader(show) {
    if (globalLoader) {
        globalLoader.style.display = show ? 'flex' : 'none';
    }
}

function showNotification(message, type = 'info') {
    const notification = document.createElement('div');
    notification.className = `notification ${type === 'error' ? 'notification-error' : type === 'warning' ? 'notification-warning' : ''}`;
    notification.textContent = message;
    
    document.body.appendChild(notification);
    
    setTimeout(() => {
        notification.classList.add('fade-out');
        setTimeout(() => document.body.removeChild(notification), 500);
    }, 5000);
}

// Configuração de event listeners
function setupEventListeners() {
    // Controles globais
    initializeBtn.addEventListener('click', initializeIrNetBox);
    
    // Editor de scripts
    addCommandBtn.addEventListener('click', () => {
        const command = commandSelect.value;
        if (!command) {
            showStatus('Selecione um comando para adicionar', 'warning');
            return;
        }
        
        const repeat = parseInt(commandRepeatInput.value) || 1;
        const delay = parseInt(commandDelayInput.value) || 0;
        
        currentScriptCommands.push({
            command,
            repeat,
            delay
        });
        
        renderCommandList();
        showStatus('Comando adicionado com sucesso!', 'success');
        
        commandSelect.value = '';
        commandRepeatInput.value = '1';
        commandDelayInput.value = '1200';
    });
    
    saveScriptBtn.addEventListener('click', () => {
        const scriptName = scriptNameInput.value.trim();
        if (!scriptName) {
            showStatus('Por favor, insira um nome para o script.', 'warning');
            return;
        }
        
        if (currentScriptCommands.length === 0) {
            showStatus('O script deve ter pelo menos um comando.', 'warning');
            return;
        }
        
        if (activeScriptIndex !== null && scripts[activeScriptIndex]) {
            scripts[activeScriptIndex].name = scriptName;
            scripts[activeScriptIndex].commands = currentScriptCommands;
            showStatus(`Script "${scriptName}" atualizado com sucesso!`, 'success');
        } else {
            scripts.push({ name: scriptName, commands: currentScriptCommands });
            showStatus(`Script "${scriptName}" salvo com sucesso!`, 'success');
        }
        
        saveScriptsToStorage();
        loadScripts();
    });
    
    clearScriptBtn.addEventListener('click', () => {
        scriptNameInput.value = '';
        commandSelect.value = '';
        commandRepeatInput.value = '1';
        commandDelayInput.value = '1200';
        currentScriptCommands = [];
        renderCommandList();
        activeScriptIndex = null;
        showStatus('Editor limpo.', 'info');
    });
    
    // Execução de scripts
    executeScriptBtn.addEventListener('click', () => {
        if (activeScriptIndex === null) {
            showStatus('Nenhum script selecionado para execução', 'error');
            return;
        }
        
        const port = parseInt(scriptExecutionPortInput.value);
        if (isNaN(port)) {
            showStatus('Porta inválida para execução', 'error');
            return;
        }
        
        executeScript(activeScriptIndex, port);
    });
    
    executeMultiPortsBtn.addEventListener('click', () => {
        if (activeScriptIndex === null) {
            showStatus('Nenhum script selecionado para execução', 'error');
            return;
        }
        
        const portsInput = multiExecutionPortsInput.value;
        const ports = portsInput.split(',').map(p => parseInt(p.trim())).filter(p => !isNaN(p) && p >= 1 && p <= 16);
        
        if (ports.length === 0) {
            showStatus('Nenhuma porta válida especificada', 'error');
            return;
        }
        
        executeScriptOnMultiplePorts(activeScriptIndex, ports);
    });
    
    loopScriptBtn.addEventListener('click', () => {
        if (activeScriptIndex === null) {
            showStatus('Nenhum script selecionado para execução', 'error');
            return;
        }
        
        const port = parseInt(scriptExecutionPortInput.value);
        if (isNaN(port)) {
            showStatus('Porta inválida para execução', 'error');
            return;
        }
        
        const loopCount = parseInt(loopCountInput.value) || 1;
        executeScriptLoop(activeScriptIndex, loopCount, port);
    });
    
    stopScriptBtn.addEventListener('click', stopExecution);
    
    // Combinação de scripts
    combineScriptsBtn.addEventListener('click', combineScripts);
    
    // Exclusão de scripts
    deleteScriptBtn.addEventListener('click', () => {
        if (activeScriptIndex === null) return;
        
        const scriptName = scripts[activeScriptIndex].name;
        if (confirm(`Tem certeza que deseja excluir o script "${scriptName}"?`)) {
            scripts.splice(activeScriptIndex, 1);
            saveScriptsToStorage();
            loadScripts();
            activeScriptIndex = null;
            selectedScriptName.textContent = 'Nenhum script selecionado';
            deleteScriptBtn.disabled = true;
            executeScriptBtn.disabled = true;
            executeMultiPortsBtn.disabled = true;
            loopScriptBtn.disabled = true;
            stopScriptBtn.disabled = true;
            showStatus(`Script "${scriptName}" excluído com sucesso!`, 'success');
        }
    });
    
    // Importar/Exportar
    document.getElementById('export-json').addEventListener('click', () => {
        jsonDataTextarea.value = JSON.stringify(scripts, null, 2);
        showStatus('Scripts exportados para JSON!', 'success');
    });
    
    document.getElementById('import-json').addEventListener('click', () => {
        try {
            const importedScripts = JSON.parse(jsonDataTextarea.value);
            
            if (!Array.isArray(importedScripts)) {
                throw new Error('O JSON deve conter um array de scripts');
            }
            
            const isValid = importedScripts.every(script =>
                typeof script.name === 'string' &&
                Array.isArray(script.commands) &&
                script.commands.every(cmd =>
                    typeof cmd.command === 'string' &&
                    typeof cmd.repeat === 'number' && cmd.repeat >= 1 &&
                    (typeof cmd.delay === 'number' || typeof cmd.delay === 'undefined')
                )
            );
            
            if (!isValid) {
                throw new Error('Formato de script JSON inválido.');
            }
            
            if (confirm('Isso substituirá todos os scripts existentes. Deseja continuar?')) {
                scripts = importedScripts;
                saveScriptsToStorage();
                loadScripts();
                showStatus('Scripts importados com sucesso!', 'success');
                jsonDataTextarea.value = '';
            }
        } catch (error) {
            showStatus(`Erro ao importar JSON: ${error.message}`, 'error');
        }
    });
    
    document.getElementById('save-json-file').addEventListener('click', () => {
        const data = JSON.stringify(scripts, null, 2);
        const blob = new Blob([data], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        
        const a = document.createElement('a');
        a.href = url;
        a.download = 'scripts-controle-claro.json';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        showStatus('Arquivo JSON gerado com sucesso!', 'success');
    });
    
    document.getElementById('load-json-file').addEventListener('click', () => {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';
        input.onchange = e => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(event) {
                    try {
                        const importedData = JSON.parse(event.target.result);
                        if (!Array.isArray(importedData)) {
                            showStatus('O arquivo JSON deve conter um array de scripts.', 'error');
                            return;
                        }
                        
                        if (confirm('Isso substituirá todos os scripts existentes. Deseja continuar?')) {
                            scripts = importedData;
                            saveScriptsToStorage();
                            loadScripts();
                            showStatus('Scripts carregados do arquivo com sucesso!', 'success');
                        }
                    } catch (error) {
                        showStatus(`Erro ao carregar arquivo JSON: ${error.message}`, 'error');
                    }
                };
                reader.readAsText(file);
            }
        };
        input.click();
    });
    
    // Gerenciamento de logs
    saveExecutionLogBtn.addEventListener('click', () => {
        if (currentExecutionLogs.length === 0) {
            showStatus('Nenhum log para salvar.', 'warning');
            return;
        }
        
        const logName = prompt('Digite um nome para este log:', `Log ${new Date().toLocaleString()}`);
        if (!logName) return;
        
        const logContent = currentExecutionLogs.map(log => 
            `[${new Date(log.timestamp).toLocaleTimeString()}] ${log.message}`
        ).join('\n');
        
        executionLogs.push({
            name: logName,
            date: new Date().toISOString(),
            content: logContent
        });
        
        saveLogsToStorage();
        loadExecutionLogs();
        showStatus('Log salvo com sucesso!', 'success');
    });
    
    clearExecutionLogsBtn.addEventListener('click', () => {
        if (executionLogs.length === 0) {
            showStatus('Nenhum log para limpar.', 'warning');
            return;
        }
        
        if (confirm('Tem certeza que deseja limpar todos os logs de execução?')) {
            executionLogs = [];
            saveLogsToStorage();
            loadExecutionLogs();
            showStatus('Todos os logs foram removidos.', 'success');
        }
    });
    
    // Agendamento
    addScheduleBtn.addEventListener('click', saveSchedule);
    
    // Event listeners para os botões de script na sidebar
    document.addEventListener('click', function(e) {
        if (e.target.classList.contains('btn-execute') && e.target.parentElement.classList.contains('script-actions')) {
            const index = parseInt(e.target.getAttribute('data-index'));
            selectScript(index);
            executeScript(index, 1); // Executa na porta 1 por padrão
            e.stopPropagation();
        }
        
        if (e.target.classList.contains('btn-edit') && e.target.parentElement.classList.contains('script-actions')) {
            const index = parseInt(e.target.getAttribute('data-index'));
            editScript(index);
            e.stopPropagation();
        }
        
        if (e.target.classList.contains('btn-danger') && e.target.parentElement.classList.contains('script-actions')) {
            const index = parseInt(e.target.getAttribute('data-index'));
            if (confirm(`Tem certeza que deseja excluir o script "${scripts[index].name}"?`)) {
                scripts.splice(index, 1);
                saveScriptsToStorage();
                loadScripts();
                
                if (activeScriptIndex === index) {
                    activeScriptIndex = null;
                    selectedScriptName.textContent = 'Nenhum script selecionado';
                    deleteScriptBtn.disabled = true;
                    executeScriptBtn.disabled = true;
                    executeMultiPortsBtn.disabled = true;
                    loopScriptBtn.disabled = true;
                }
                
                showStatus(`Script excluído com sucesso!`, 'success');
            }
            e.stopPropagation();
        }
    });
    
    // Event listeners para agendamentos
    schedulesList.addEventListener('click', function(e) {
        if (e.target.classList.contains('delete-schedule')) {
            const index = parseInt(e.target.getAttribute('data-index'));
            deleteSchedule(index);
        }
        
        if (e.target.classList.contains('execute-now')) {
            const index = parseInt(e.target.getAttribute('data-index'));
            executeScheduleNow(index);
        }
        
        if (e.target.classList.contains('edit-schedule')) {
            const index = parseInt(e.target.getAttribute('data-index'));
            editSchedule(index);
        }
    });
    
    // Controle de portas
    document.addEventListener('click', function(e) {
        if (e.target.classList.contains('port-activate')) {
            const port = parseInt(e.target.dataset.port);
            const portCard = document.querySelector(`.port-card[data-port="${port}"]`);
            
            // Ativa/desativa a porta
            if (portCard.classList.contains('active')) {
                portCard.classList.remove('active');
                e.target.textContent = 'Ativar Porta';
                updatePortStatus(port, 'inactive', 'Inativa');
                activePorts[port] = false;
                logToPort(port, 'Porta desativada');
            } else {
                portCard.classList.add('active');
                e.target.textContent = 'Desativar Porta';
                updatePortStatus(port, 'active', 'Ativa');
                activePorts[port] = true;
                logToPort(port, 'Porta ativada');
            }
        }
        
        if (e.target.classList.contains('port-execute')) {
            const port = parseInt(e.target.dataset.port);
            const portCard = document.querySelector(`.port-card[data-port="${port}"]`);
            const scriptSelect = portCard.querySelector('.port-script-select');
            const selectedOptions = Array.from(scriptSelect.selectedOptions);
            
            if (selectedOptions.length === 0) {
                logToPort(port, 'Nenhum script selecionado para execução', 'error');
                return;
            }
            
            // Limpa a fila atual e adiciona os novos scripts
            portScriptQueues[port] = selectedOptions.map(option => ({
                scriptIndex: parseInt(option.value),
                loopCount: 1 // Padrão para execução única
            }));
            
            updateQueueDisplay(port);
            
            // Remove o botão de ativar porta e ativa automaticamente
            const activateButton = portCard.querySelector('.port-activate');
            if (activateButton) {
                activateButton.style.display = 'none';
            }
            
            // Ativa a porta automaticamente
            portCard.classList.add('active');
            updatePortStatus(port, 'active', 'Ativa');
            activePorts[port] = true;
            logToPort(port, `${selectedOptions.length} script(s) adicionado(s) à fila de execução`);
            
            // Inicia a execução da fila
            executeScriptQueueOnPort(port);
            
            // Executa o script
            executeScriptOnPort(port, parseInt(scriptIndex));
        }
        
        
        if (e.target.classList.contains('port-execute-loop')) {
            const port = parseInt(e.target.dataset.port);
            const portCard = document.querySelector(`.port-card[data-port="${port}"]`);
            const scriptSelect = portCard.querySelector('.port-script-select');
            const loopCountInput = portCard.querySelector('.port-loop-count');
            const scriptIndex = scriptSelect.value;
            const loopCount = parseInt(loopCountInput.value) || 1;
            
            if (!scriptIndex) {
                logToPort(port, 'Nenhum script selecionado para execução', 'error');
                return;
            }
            
            // Remove o botão de ativar porta e ativa automaticamente
            const activateButton = portCard.querySelector('.port-activate');
            if (activateButton) {
                activateButton.style.display = 'none';
            }
            
            // Ativa a porta automaticamente
            portCard.classList.add('active');
            updatePortStatus(port, 'active', 'Ativa');
            activePorts[port] = true;
            logToPort(port, 'Porta ativada automaticamente para execução em loop');
            
            executeScriptLoopOnPort(port, parseInt(scriptIndex), loopCount);
        }
        
        if (e.target.classList.contains('port-stop')) {
            const port = parseInt(e.target.dataset.port);
            stopPortExecution(port);
            
            // Restaura o botão de ativar porta
            const portCard = document.querySelector(`.port-card[data-port="${port}"]`);
            const activateButton = portCard.querySelector('.port-activate');
            if (activateButton) {
                activateButton.style.display = 'block';
            }
        }
    });
    
    enableAllPortsBtn.addEventListener('click', function() {
        document.querySelectorAll('.port-card').forEach(card => {
            const port = parseInt(card.dataset.port);
            card.classList.add('active');
            const activateButton = card.querySelector('.port-activate');
            if (activateButton) {
                activateButton.textContent = 'Desativar Porta';
            }
            updatePortStatus(port, 'active', 'Ativa');
            activePorts[port] = true;
            logToPort(port, 'Porta ativada (todas as portas)');
        });
        showStatus('Todas as portas ativadas', 'success');
    });
    
    disableAllPortsBtn.addEventListener('click', function() {
        document.querySelectorAll('.port-card').forEach(card => {
            const port = parseInt(card.dataset.port);
            card.classList.remove('active');
            const activateButton = card.querySelector('.port-activate');
            if (activateButton) {
                activateButton.textContent = 'Ativar Porta';
                activateButton.style.display = 'block';
            }
            updatePortStatus(port, 'inactive', 'Inativa');
            activePorts[port] = false;
            logToPort(port, 'Porta desativada (todas as portas)');
        });
        showStatus('Todas as portas desativadas', 'success');
    });
    
    executeAllScriptsBtn.addEventListener('click', async function() {
        const activePortCards = Array.from(document.querySelectorAll('.port-card.active'));
        
        if (activePortCards.length === 0) {
            showStatus('Nenhuma porta ativa para executar scripts', 'warning');
            return;
        }

        // Coleta todos os scripts selecionados nas portas ativas
        const scriptsToExecute = [];
        const ports = [];
        
        activePortCards.forEach(card => {
            const port = parseInt(card.dataset.port);
            const scriptSelect = card.querySelector('.port-script-select');
            const scriptIndex = scriptSelect.value;
            
            if (scriptIndex) {
                scriptsToExecute.push(parseInt(scriptIndex));
                ports.push(port);
                
                // Remove o botão de ativar porta e ativa automaticamente (caso não esteja ativa)
                if (!card.classList.contains('active')) {
                    card.classList.add('active');
                    const activateButton = card.querySelector('.port-activate');
                    if (activateButton) {
                        activateButton.style.display = 'none';
                    }
                    updatePortStatus(port, 'active', 'Ativa');
                    activePorts[port] = true;
                    logToPort(port, 'Porta ativada automaticamente para execução');
                }
            }
        });

        if (scriptsToExecute.length === 0) {
            showStatus('Nenhum script selecionado nas portas ativas', 'warning');
            return;
        }

        showStatus(`Executando ${scriptsToExecute.length} script(s) em ${ports.length} porta(s) ativa(s)`, 'info');

        // Executa sequencialmente cada script nas portas selecionadas
        for (const scriptIndex of scriptsToExecute) {
            const scriptName = scripts[scriptIndex].name;
            showStatus(`Executando script "${scriptName}" nas portas selecionadas`, 'info');
            
            // Executa o script atual em todas as portas selecionadas
            for (const port of ports) {
                try {
                    logToPort(port, `Iniciando execução do script "${scriptName}"`);
                    await executeScriptOnPort(port, scriptIndex);
                    logToPort(port, `Script "${scriptName}" concluído com sucesso`, 'success');
                } catch (error) {
                    logToPort(port, `Erro ao executar script "${scriptName}": ${error.message}`, 'error');
                }
            }
        }

        showStatus('Todos os scripts foram executados nas portas selecionadas', 'success');
    });
    stopAllExecutionsBtn.addEventListener('click', function() {
        // Para todas as execuções globais
        stopExecution();
        
        // Para todas as execuções em portas
        for (let port = 1; port <= 16; port++) {
            stopPortExecution(port);
            
            // Restaura o botão de ativar porta para todas as portas
            const portCard = document.querySelector(`.port-card[data-port="${port}"]`);
            if (portCard) {
                const activateButton = portCard.querySelector('.port-activate');
                if (activateButton) {
                    activateButton.style.display = 'block';
                }
            }
        }
        
        showStatus('Todas as execuções foram interrompidas', 'warning');
    });
}

function setupTabNavigation() {
    document.querySelectorAll('.tab').forEach(tab => {
        tab.addEventListener('click', () => {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            
            tab.classList.add('active');
            const tabId = tab.getAttribute('data-tab');
            document.getElementById(`${tabId}-tab`).classList.add('active');
            
            if (tabId === 'management') {
                loadExecutionLogs();
            }
        });
    });
}

function loadExecutionLogs() {
    logListContainer.innerHTML = '';
    
    if (executionLogs.length === 0) {
        logListContainer.innerHTML = '<p>Nenhum log salvo ainda</p>';
        return;
    }
    
    executionLogs.sort((a, b) => new Date(b.date) - new Date(a.date));
    
    executionLogs.forEach((log, index) => {
        const logItem = document.createElement('div');
        logItem.className = 'log-item';
        
        logItem.innerHTML = `
            <div class="log-item-header">
                <span class="log-item-name">${log.name}</span>
                <span class="log-item-date">${new Date(log.date).toLocaleString()}</span>
            </div>
            <div class="log-item-content">${log.content.substring(0, 100)}${log.content.length > 100 ? '...' : ''}</div>
            <div class="log-actions">
                <button class="btn-execute" data-index="${index}">Visualizar</button>
                <button class="btn-danger" data-index="${index}">Excluir</button>
            </div>
        `;
        
        logItem.querySelectorAll('button').forEach(button => {
            button.addEventListener('click', (e) => {
                const logIndex = parseInt(e.target.getAttribute('data-index'));
                if (e.target.classList.contains('btn-execute')) {
                    viewLog(logIndex);
                } else if (e.target.classList.contains('btn-danger')) {
                    deleteLog(logIndex);
                }
            });
        });
        
        logListContainer.appendChild(logItem);
    });
}

function viewLog(index) {
    const log = executionLogs[index];
    
    const modal = document.createElement('div');
    modal.style.position = 'fixed';
    modal.style.top = '0';
    modal.style.left = '0';
    modal.style.width = '100%';
    modal.style.height = '100%';
    modal.style.backgroundColor = 'rgba(0,0,0,0.7)';
    modal.style.display = 'flex';
    modal.style.justifyContent = 'center';
    modal.style.alignItems = 'center';
    modal.style.zIndex = '1000';
    
    const modalContent = document.createElement('div');
    modalContent.style.backgroundColor = 'white';
    modalContent.style.padding = '20px';
    modalContent.style.borderRadius = '8px';
    modalContent.style.maxWidth = '90%';
    modalContent.style.maxHeight = '90%';
    modalContent.style.overflow = 'auto';
    
    modalContent.innerHTML = `
        <h3 style="margin-bottom: 15px;">${log.name}</h3>
        <p style="margin-bottom: 15px; color: #666;">${new Date(log.date).toLocaleString()}</p>
        <pre style="white-space: pre-wrap; font-family: 'Roboto Mono', monospace; background-color: #f5f5f5; padding: 15px; border-radius: 6px;">${log.content}</pre>
        <div style="margin-top: 20px; text-align: center;">
            <button id="close-modal" style="padding: 8px 16px; background-color: var(--claro-primary); color: white; border: none; border-radius: 4px; cursor: pointer;">Fechar</button>
        </div>
    `;
    
    modal.appendChild(modalContent);
    document.body.appendChild(modal);
    
    modalContent.querySelector('#close-modal').addEventListener('click', () => {
        document.body.removeChild(modal);
    });
}

function deleteLog(index) {
    if (confirm('Tem certeza que deseja excluir este log?')) {
        executionLogs.splice(index, 1);
        saveLogsToStorage();
        loadExecutionLogs();
        showStatus('Log excluído com sucesso!', 'success');
    }
}

// Funções de drag and drop
function handleCommandDragStart(e) {
    draggedCommandIndex = parseInt(e.target.closest('.command-item').dataset.index);
    e.target.classList.add('dragging');
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('text/plain', draggedCommandIndex);
}

function handleCommandDragOver(e) {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
    
    const commandItem = e.target.closest('.command-item');
    if (commandItem && commandItem.dataset.index !== draggedCommandIndex) {
        const commandIndex = parseInt(commandItem.dataset.index);
        const rect = commandItem.getBoundingClientRect();
        const midpoint = rect.top + rect.height / 2;
        
        if (e.clientY < midpoint) {
            commandItem.style.borderTop = '2px solid var(--claro-primary)';
            commandItem.style.borderBottom = 'none';
        } else {
            commandItem.style.borderBottom = '2px solid var(--claro-primary)';
            commandItem.style.borderTop = 'none';
        }
    }
}

function handleCommandDrop(e) {
    e.preventDefault();
    
    const commandItem = e.target.closest('.command-item');
    if (commandItem && draggedCommandIndex !== null) {
        const dropIndex = parseInt(commandItem.dataset.index);
        const rect = commandItem.getBoundingClientRect();
        const midpoint = rect.top + rect.height / 2;
        
        document.querySelectorAll('.command-item').forEach(item => {
            item.style.borderTop = 'none';
            item.style.borderBottom = 'none';
        });
        
        const commandToMove = currentScriptCommands[draggedCommandIndex];
        currentScriptCommands.splice(draggedCommandIndex, 1);
        
        const newIndex = e.clientY < midpoint ? dropIndex : dropIndex + 1;
        currentScriptCommands.splice(newIndex, 0, commandToMove);
        
        renderCommandList();
        showStatus('Ordem dos comandos atualizada.', 'info');
    }
}

function handleCommandDragEnd(e) {
    document.querySelectorAll('.command-item').forEach(item => {
        item.style.borderTop = 'none';
        item.style.borderBottom = 'none';
        item.classList.remove('dragging');
    });
    
    draggedCommandIndex = null;
}
    </script>
</body>
</html>
